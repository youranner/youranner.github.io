<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统期末复习 | YOURanner</title><meta name="keywords" content="操作系统"><meta name="author" content="shrilly"><meta name="copyright" content="shrilly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="操作系统引论操作系统的目标和作用操作系统的目标 方便性  有效性  可扩容性  开放性   操作系统的作用 OS作为用户和硬件系统之间的接口 OS作为计算机系统资源的管理者 OS作为对计算机资源的抽象  操作系统的发展过程 无操作系统的计算机系统  单道批操作系统  多道批操作系统  分时系统 多路线 及时性 独立性 交互性  实时系统  微机操作系统   操作系统的基本特征 并发性 一段时间内，">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统期末复习">
<meta property="og:url" content="https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="YOURanner">
<meta property="og:description" content="操作系统引论操作系统的目标和作用操作系统的目标 方便性  有效性  可扩容性  开放性   操作系统的作用 OS作为用户和硬件系统之间的接口 OS作为计算机系统资源的管理者 OS作为对计算机资源的抽象  操作系统的发展过程 无操作系统的计算机系统  单道批操作系统  多道批操作系统  分时系统 多路线 及时性 独立性 交互性  实时系统  微机操作系统   操作系统的基本特征 并发性 一段时间内，">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg">
<meta property="article:published_time" content="2020-11-29T03:40:25.000Z">
<meta property="article:modified_time" content="2020-12-09T08:06:04.671Z">
<meta property="article:author" content="shrilly">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-09 16:06:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YOURanner</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">操作系统期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-11-29T03:40:25.000Z" title="Created 2020-11-29 11:40:25">2020-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-12-09T08:06:04.671Z" title="Updated 2020-12-09 16:06:04">2020-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/knowledge/">knowledge</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><h3 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h3><h4 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h4><ul>
<li><p>方便性</p>
</li>
<li><p>有效性</p>
</li>
<li><p>可扩容性</p>
</li>
<li><p>开放性</p>
</li>
</ul>
<h4 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h4><ul>
<li>OS作为用户和硬件系统之间的接口</li>
<li>OS作为计算机系统资源的管理者</li>
<li>OS作为对计算机资源的抽象</li>
</ul>
<h3 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h3><ul>
<li><p>无操作系统的计算机系统</p>
</li>
<li><p>单道批操作系统</p>
</li>
<li><p>多道批操作系统</p>
</li>
<li><p>分时系统</p>
<p>多路线</p>
<p>及时性</p>
<p>独立性</p>
<p>交互性</p>
</li>
<li><p>实时系统</p>
</li>
<li><p>微机操作系统</p>
</li>
</ul>
<h3 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h3><ul>
<li><p>并发性</p>
<p>一段时间内，多个程序同时运行。</p>
</li>
<li><p>共享性</p>
<p>互斥共享</p>
<p>同时访问</p>
</li>
<li><p>虚拟性</p>
</li>
<li><p>异步性</p>
<p>程序以不可预知的速度向前运行</p>
</li>
</ul>
<h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>友好的用户接口</li>
<li>现代操作系统的新功能</li>
</ul>
<h3 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h3><ul>
<li><p>无结构OS</p>
</li>
<li><p>模块化OS</p>
</li>
<li><p>分层次OS</p>
<p>优点</p>
<ol>
<li>易保护系统的正确性</li>
<li>易扩展和易维护性</li>
</ol>
<p>缺点</p>
<p>​     系统效率降低</p>
</li>
<li><p>微内核OS</p>
</li>
</ul>
<p>基本概念</p>
<ol>
<li>足够小的内核</li>
<li>集与客户/服务器模式</li>
<li>应用机制与策略分离原理</li>
<li>采用面向对象技术</li>
</ol>
<p>优点</p>
<ol>
<li>提高了系统的可扩展性</li>
<li>增强了系统的可靠性</li>
<li>可移植性强</li>
<li>提供了对分布式系统的支持</li>
<li>融入了面向对象技术</li>
</ol>
<h2 id="进程的描述与控制"><a href="#进程的描述与控制" class="headerlink" title="进程的描述与控制"></a>进程的描述与控制</h2><h3 id="前驱图和程序执行"><a href="#前驱图和程序执行" class="headerlink" title="前驱图和程序执行"></a>前驱图和程序执行</h3><h4 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h4><p>有向无循环图</p>
<h4 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h4><ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可在现性</li>
</ul>
<h4 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><ul>
<li>间断性</li>
<li>失去封闭性</li>
<li>不可再现性</li>
</ul>
<h3 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h3><h4 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h4><h5 id="定义-PCB"><a href="#定义-PCB" class="headerlink" title="定义(PCB)"></a>定义(PCB)</h5><ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所 发生的活动</li>
<li>系统进行资源分配和调度的一个独立单位</li>
</ul>
<h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li> 异步性</li>
</ul>
<h4 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h4><h5 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h5><ul>
<li> 就绪(Ready)状态</li>
<li> 阻塞(Block)状态</li>
<li>执行(Running)状态</li>
</ul>
<h5 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h5><img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/jincheng.png" class title="This is an image">

<h5 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h5><img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/sanzhong.png" class title="This is an image">

<ul>
<li>创建状态 </li>
</ul>
<p>创建一个进程是个很 复杂的过程，一般要通过多个步骤才能完成：如首先由进程 申请一个空白PCB，并向PCB中填写用于控制和管理进程的 信息；然后为该进程分配运行时所必须的资源；最后，把该 进程转入就绪状态并插入就绪队列之中。但如果进程所需的 资源尚不能得到满足，比如系统尚无足够的内存使进程无法 装入其中，此时创建工作尚未完成，进程不能被调度运行， 于是把此时进程所处的状态称为创建状态。</p>
<ul>
<li>终止状态</li>
</ul>
<p>进程的终止也要通过两个步骤：首先，是等待操作系统 进行善后处理，最后将其PCB清零，并将PCB空间返还系统。 当一个进程到达了自然结束点，或是出现了无法克服的错误， 或是被操作系统所终结，或是被其他有终止权的进程所终结， 它将进入终止状态。进入终止态的进程以后不能再执行，但 在操作系统中依然保留一个记录，其中保存状态码和一些计 时统计数据，供其他进程收集。一旦其他进程完成了对其信 息的提取之后，操作系统将删除该进程，即将其PCB清零， 并将该空白PCB返还系统。</p>
<h5 id="挂起操作和进程状态的转换"><a href="#挂起操作和进程状态的转换" class="headerlink" title="挂起操作和进程状态的转换"></a>挂起操作和进程状态的转换</h5><ul>
<li>挂起操作的引入 </li>
</ul>
<p>(1) 终端用户的需要。</p>
<p> (2) 父进程请求。</p>
<p> (3) 负荷调节的需要。</p>
<p> (4) 操作系统的需要</p>
<ul>
<li> 引入挂起原语操作后三个进程状态的转换 </li>
</ul>
<p>(1) 活动就绪→静止就绪。 </p>
<p>(2) 活动阻塞→静止阻塞。</p>
<p> (3) 静止就绪→活动就绪。</p>
<p> (4) 静止阻塞→活动阻塞</p>
<ul>
<li>引入挂起操作后五个进程状态的转换 </li>
</ul>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/wuzhong.png" class title="This is an image">

<h5 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h5><ul>
<li>操作系统中用于管理控制的数据结构</li>
<li>进程控制块PCB的作用 </li>
</ul>
<p>(1) 作为独立运行基本单位的标志。 </p>
<p>(2) 能实现间断性运行方式。</p>
<p> (3) 提供进程管理所需要的信息。</p>
<p> (4) 提供进程调度所需要的信息。</p>
<p> (5) 实现与其它进程的同步与通信。</p>
<ul>
<li>进程控制块中的信息 </li>
</ul>
<ol>
<li><p> 进程标识符 </p>
</li>
<li><p>处理机状态</p>
</li>
<li><p>进程调度信息 </p>
<p>这些信息包括：① 进程状态，指明进程的当前状态， 它是作为进程调度和对换时的依据；② 进程优先级，是用于 描述进程使用处理机的优先级别的一个整数，优先级高的进 程应优先获得处理机；③ 进程调度所需的其它信息，它们与 所采用的进程调度算法有关，比如，进程已等待CPU的时间 总和、进程已执行的时间总和等；④ 事件，是指进程由执行 状态转变为阻塞状态所等待发生的事件，即阻塞原因。</p>
</li>
<li><p>进程控制信息 </p>
<p>包括：① 程序和数 据的地址，进程实体中的程序和数据的内存或外存地(首)址， 以便再调度到该进程执行时，能从PCB中找到其程序和数据； ② 进程同步和通信机制，这是实现进程同步和进程通信时必 需的机制，如消息队列指针、信号量等，它们可能全部或部 分地放在PCB中；③ 资源清单，在该清单中列出了进程在运 行期间所需的全部资源(除CPU以外)，另外还有一张已分配 到该进程的资源的清单；④ 链接指针，它给出了本进程 (PCB)所在队列中的下一个进程的PCB的首地址。</p>
</li>
</ol>
<ul>
<li>进程控制块的组织方式 </li>
</ul>
<ol>
<li> 线性方式</li>
<li> 链接方式</li>
<li> 索引方式</li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h4><h5 id="支撑功能"><a href="#支撑功能" class="headerlink" title="支撑功能"></a>支撑功能</h5><ul>
<li>中断处理</li>
<li>时钟管理</li>
<li> 原语操作</li>
</ul>
<h5 id="资源管理功能"><a href="#资源管理功能" class="headerlink" title="资源管理功能"></a>资源管理功能</h5><ul>
<li> 进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><h5 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h5><p>在OS中，允许一个进程创建另一个进程，通常把创建进 程的进程称为父进程，而把被创建的进程称为子进程。子进 程可继续创建更多的孙进程，由此便形成了一个进程的层次 结构。如在UNIX中，进程与其子孙进程共同组成一个进程 家族(组)。</p>
<h5 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h5><h5 id="引起创建进程的事件"><a href="#引起创建进程的事件" class="headerlink" title="引起创建进程的事件"></a>引起创建进程的事件</h5><p>为使程序之间能并发运行，应先为它们分别创建进程。 导致一个进程去创建另一个进程的典型事件有四类：</p>
<p> (1) 用户登录。 (2) 作业调度。 (3) 提供服务。 (4) 应用请求。</p>
<h5 id="进程的创建-Creation-of-Process"><a href="#进程的创建-Creation-of-Process" class="headerlink" title="进程的创建(Creation of Process)"></a>进程的创建(Creation of Process)</h5><p>在系统中每当出现了创建新进程的请求后，OS便调用进 程创建原语Creat按下述步骤创建一个新进程： (1) 申请空白PCB，为新进程申请获得唯一的数字标识符， 并从PCB集合中索取一个空白PCB。 (2) 为新进程分配其运行所需的资源，包括各种物理和 逻辑资源，如内存、文件、I/O设备和CPU时间等。 (3) 初始化进程控制块(PCB)。 (4) 如果进程就绪队列能够接纳新进程，便将新进程插 入就绪队列。</p>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><h5 id="引起进程终止-Termination-of-Process-的事件"><a href="#引起进程终止-Termination-of-Process-的事件" class="headerlink" title="引起进程终止(Termination of Process)的事件"></a>引起进程终止(Termination of Process)的事件</h5><p>(1) 正常结束 (2) 异常结束 (3) 外界干预</p>
<h5 id="进程的终止过程"><a href="#进程的终止过程" class="headerlink" title="进程的终止过程"></a>进程的终止过程</h5><p>(1) 根据被终止进程的标识符，从PCB集合中检索出该进 程的PCB，从中读出该进程的状态； (2) 若被终止进程正处于执行状态，应立即终止该进程 的执行，并置调度标志为真，用于指示该进程被终止后应重 新进行调度；</p>
<p>(3) 若该进程还有子孙进程，还应将其所有子孙进程也 都予以终止，以防它们成为不可控的进程； (4) 将被终止进程所拥有的全部资源或者归还给其父进 程，或者归还给系统； (5) 将被终止进程(PCB)从所在队列(或链表)中移出，等 待其它程序来搜集信息。</p>
<h4 id="进程的阻塞与唤醒"><a href="#进程的阻塞与唤醒" class="headerlink" title="进程的阻塞与唤醒"></a>进程的阻塞与唤醒</h4><h4 id="进程的挂起与激活"><a href="#进程的挂起与激活" class="headerlink" title="进程的挂起与激活"></a>进程的挂起与激活</h4><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>在OS中引入进程后，一方面可以使系统中的多道程序并 发执行，这不仅能有效地改善资源利用率，还可显著地提高 系统的吞吐量，但另一方面却使系统变得更加复杂。如果不 能采取有效的措施，对多个进程的运行进行妥善的管理，必 然会因为这些进程对系统资源的无序争夺给系统造成混乱。 致使每次处理的结果存在着不确定性，即显现出其不可再现 性。</p>
<h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><h5 id="两种形式的制约关系"><a href="#两种形式的制约关系" class="headerlink" title="两种形式的制约关系"></a>两种形式的制约关系</h5><ol>
<li>间接相互制约关系 2) 直接相互制约关系</li>
</ol>
<h5 id="临界资源-Critical-Resouce"><a href="#临界资源-Critical-Resouce" class="headerlink" title="临界资源(Critical Resouce)"></a>临界资源(Critical Resouce)</h5><p>在第一章中我们曾经介绍过，许多硬件资源如打印机、 磁带机等，都属于临界资源，诸进程间应采取互斥方式，实 现对这种资源的共享。</p>
<h5 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区(critical section)"></a>临界区(critical section)</h5><p>由前所述可知，不论是硬件临界资源还是软件临界资源，</p>
<p>多个进程必须互斥地对它进行访问。人们把在每个进程中访 问临界资源的那段代码称为临界区(critical section)。</p>
<h5 id="同步机制应遵循的规则"><a href="#同步机制应遵循的规则" class="headerlink" title="同步机制应遵循的规则"></a>同步机制应遵循的规则</h5><p>所有同步机制都应遵循下述四条准则：</p>
<p> (1) 空闲让进。 (2) 忙则等待。 (3) 有限等待。 (4) 让权等待。</p>
<h4 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h4><h5 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h5><p>① 滥用关中断 权力可能导致严重后果；② 关中断时间过长，会影响系统效 率，限制了处理器交叉执行程序的能力；③ 关中断方法也不 适用于多CPU 系统，因为在一个处理器上关中断并不能防止 进程在其它处理器上执行相同的临界段代码。</p>
<h5 id="利用Test-and-Set指令实现互斥"><a href="#利用Test-and-Set指令实现互斥" class="headerlink" title="利用Test-and-Set指令实现互斥"></a>利用Test-and-Set指令实现互斥</h5><h5 id="利用Swap指令实现进程互斥"><a href="#利用Swap指令实现进程互斥" class="headerlink" title="利用Swap指令实现进程互斥"></a>利用Swap指令实现进程互斥</h5><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><strong>信号量机制</strong></h4><h5 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int s&#x3D;1;</span><br><span class="line">void wait(int s)</span><br><span class="line">&#123;</span><br><span class="line">while(s&lt;&#x3D;0);</span><br><span class="line">s&#x3D;s-1;</span><br><span class="line">&#125;</span><br><span class="line">void signal(int s)</span><br><span class="line">&#123;</span><br><span class="line">s&#x3D;s+1;</span><br><span class="line">&#125;</span><br><span class="line">进程p0</span><br><span class="line">....</span><br><span class="line">wait(s);</span><br><span class="line">使用打印机资源...</span><br><span class="line">signal(s);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>

<h5 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">int value;</span><br><span class="line">struct prcess *L;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">void wait(semaphore s)&#123;</span><br><span class="line">s.value--;</span><br><span class="line">if(s.value&lt;0)&#123;</span><br><span class="line">block(s.L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void signal(semaphore s)&#123;</span><br><span class="line">s.value++;</span><br><span class="line">if(s.value&lt;&#x3D;0)</span><br><span class="line">wakeup(s.L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a><strong>信号量的应用</strong></h4><h5 id="利用信号量实现进程互斥"><a href="#利用信号量实现进程互斥" class="headerlink" title="利用信号量实现进程互斥"></a>利用信号量实现进程互斥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;</span><br><span class="line">p1()&#123;</span><br><span class="line">...</span><br><span class="line">p(mutex);</span><br><span class="line">临界区代码...</span><br><span class="line">v(mutex);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p2()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">p(mutex);</span><br><span class="line">临界区代码...</span><br><span class="line">v(mutex);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore s&#x3D;0;</span><br><span class="line">p1()</span><br><span class="line">&#123;</span><br><span class="line">...;</span><br><span class="line">v(s);</span><br><span class="line">&#125;</span><br><span class="line">p2()</span><br><span class="line">&#123;</span><br><span class="line">p(s);</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经典进程的同步问题"><a href="#经典进程的同步问题" class="headerlink" title="经典进程的同步问题"></a>经典进程的同步问题</h3><h4 id="决生产者-消费者问题"><a href="#决生产者-消费者问题" class="headerlink" title="决生产者-消费者问题"></a>决生产者-消费者问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;</span><br><span class="line">semaphore empty&#x3D;n;</span><br><span class="line">semaphore empty&#x3D;0;</span><br><span class="line">producter()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">	生产一个产品;</span><br><span class="line">	p(empty);</span><br><span class="line">	p(mutex);</span><br><span class="line">	将产品放入缓冲区;</span><br><span class="line">	v(mutex);</span><br><span class="line">	v(full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer()</span><br><span class="line">&#123;</span><br><span class="line">	p(full);</span><br><span class="line">	p(mutex);</span><br><span class="line">	将产品取出缓冲区;</span><br><span class="line">	v(mutex);</span><br><span class="line">	v(empty);</span><br><span class="line">	使用产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex&#x3D;1;</span><br><span class="line">semaphore chopstick[5]&#x3D;&#123;1,1,1,1,1&#125;;</span><br><span class="line">pi()</span><br><span class="line">&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">	p(mutex);</span><br><span class="line">	p(chopstick[i]);</span><br><span class="line">	p(chopstick[i+1]%5);</span><br><span class="line">	v(mutex);</span><br><span class="line">	吃饭;</span><br><span class="line">	v(chopstick[i]);</span><br><span class="line">	v(chopstick[i+1]%5);</span><br><span class="line">	思考;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore wmutex &#x3D; 1;</span><br><span class="line">semaphore rmutex &#x3D; 1;</span><br><span class="line">int readcount &#x3D; 0;&#x2F;&#x2F; 记录有几个读者</span><br><span class="line">void reader()</span><br><span class="line">&#123;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(rmutex); &#x2F;&#x2F; rmutex是为了保护readcount共享变量</span><br><span class="line">		if(readcount &#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			wait(wmutex);&#x2F;&#x2F; 保证第一个读进程来，写进程就不能进行</span><br><span class="line">		&#125;</span><br><span class="line">		readcount++;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		&#x2F;&#x2F; 读的过程</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount--;</span><br><span class="line">		if(readcount &#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			signal(wmutex); &#x2F;&#x2F; 保证最后一个读进程读完，释放wmutex信号量</span><br><span class="line">		&#125;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void writer()</span><br><span class="line">&#123;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(wmutex);</span><br><span class="line">		&#x2F;&#x2F; 写的过程</span><br><span class="line">		signal(wmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="进程通信的类型"><a href="#进程通信的类型" class="headerlink" title="进程通信的类型"></a>进程通信的类型</h4><ul>
<li><p>共享存储器系统(Shared-Memory System)</p>
<p>在共享存储器系统中，相互通信的进程共享某些数据结</p>
<p>构或共享存储区，进程之间能够通过这些空间进行通信。</p>
</li>
<li><p> 管道(pipe)通信系统 </p>
</li>
</ul>
<p>​     所谓“管道”，是指用于连接一个读进程和一个写进程 以实现它们之间通信的一个共享文件，又名pipe文件。向管 道(共享文件)提供输入的发送进程(即写进程)以字符流形式 将大量的数据送入管道；而接受管道输出的接收进程(即读 进程)则从管道中接收(读)数据。由于发送进程和接收进程是 利用管道进行通信的，故又称为管道通信</p>
<ul>
<li> 消息传递系统(Message passing system) </li>
</ul>
<p>在该机制中，进程不必借助任何共享存储区或数据结构， 而是以格式化的消息 (message)为单位，将通信的数据封装在 消息中，并利用操作系统提供的一组通信命令(原语)，在进 程间进行消息传递，完成进程间的数据交换。</p>
<ul>
<li> 客户机-服务器系统(Client-Server system) </li>
</ul>
<h4 id="消息传递通信的实现方式"><a href="#消息传递通信的实现方式" class="headerlink" title="消息传递通信的实现方式"></a>消息传递通信的实现方式</h4><ul>
<li><p> 直接消息传递系统 </p>
</li>
<li><p>信箱通信 </p>
</li>
</ul>
<h3 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h3><p>如果说，在OS中引入进程的目的是为了使多个程序能并 发执行，以提高资源利用率和系统吞吐量，那么，在操作系 统中再引入线程，则是为了减少程序在并发执行时所付出的 时空开销，使OS具有更好的并发性。</p>
<h4 id="线程——作为调度和分派的基本单位"><a href="#线程——作为调度和分派的基本单位" class="headerlink" title="线程——作为调度和分派的基本单位"></a>线程——作为调度和分派的基本单位</h4><h4 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h4><ol>
<li>调度的基本单位</li>
<li> 并发性</li>
<li> 拥有资源 </li>
<li>独立性 </li>
<li>系统开销 </li>
<li>支持多处理机系统</li>
</ol>
<h4 id="线程的状态和线程控制块"><a href="#线程的状态和线程控制块" class="headerlink" title="线程的状态和线程控制块"></a>线程的状态和线程控制块</h4><h5 id="线程运行的三个状态"><a href="#线程运行的三个状态" class="headerlink" title="线程运行的三个状态"></a>线程运行的三个状态</h5><h5 id="线程控制块TCB"><a href="#线程控制块TCB" class="headerlink" title="线程控制块TCB"></a>线程控制块TCB</h5><h5 id="多线程OS中的进程属性"><a href="#多线程OS中的进程属性" class="headerlink" title="多线程OS中的进程属性"></a>多线程OS中的进程属性</h5><p>(1) 进程是一个可拥有资源的基本单位。</p>
<p> (2) 多个线程可并发执行。</p>
<p> (3) 进程已不是可执行的实体。</p>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><h5 id="内核支持线程KST-Kernel-Supported-Threads"><a href="#内核支持线程KST-Kernel-Supported-Threads" class="headerlink" title="内核支持线程KST(Kernel Supported Threads)"></a>内核支持线程KST(Kernel Supported Threads)</h5><p>这种线程实现方式主要有四个主要优点：</p>
<p> (1) 在多处理器系统中，内核能够同时调度同一进程中 的多个线程并行执行；</p>
<p> (2) 如果进程中的一个线程被阻塞了，内核可以调度该 进程中的其它线程占有处理器运行，也可以运行其它进程中 的线程；</p>
<p> (3) 内核支持线程具有很小的数据结构和堆栈，线程的 切换比较快，切换开销小；</p>
<p> (4) 内核本身也可以采用多线程技术，可以提高系统的 执行速度和效率。</p>
<h5 id="用户级线程ULT-User-Level-Threads"><a href="#用户级线程ULT-User-Level-Threads" class="headerlink" title="用户级线程ULT(User Level Threads)"></a>用户级线程ULT(User Level Threads)</h5><p>使用用户级线程方式有许多优点： (1) 线程切换不需要转换到内核空间。 (2) 调度算法可以是进程专用的。 (3) 用户级线程的实现与OS平台无关，因为对于线程管 理的代码是属于用户程序的一部分，所有的应用程序都可以 对之进行共享。</p>
<p>而用户级线程方式的主要缺点则在于： (1) 系统调用的阻塞问题。在基于进程机制的OS中，大 多数系统调用将使进程阻塞，因此，当线程执行一个系统调 用时，不仅该线程被阻塞，而且，进程内的所有线程会被阻 塞。而在内核支持线程方式中，则进程中的其它线程仍然可 以运行。 (2) 在单纯的用户级线程实现方式中，多线程应用不能 利用多处理机进行多重处理的优点，内核每次分配给一个进 程的仅有一个CPU，因此，进程中仅有一个线程能执行，在 该线程放弃CPU之前，其它线程只能等待。</p>
<p> 组合方式 </p>


<h4 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h4><h5 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h5><p>应用程序在启动时，通常仅有一个线程在执行，人们把 线程称为“初始化线程”，它的主要功能是用于创建新线程。 在创建新线程时，需要利用一个线程创建函数(或系统调用)， 并提供相应的参数，如指向线程主程序的入口指针、堆栈的 大小，以及用于调度的优先级等。在线程的创建函数执行完 后，将返回一个线程标识符供以后使用。</p>
<h5 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h5><p>当一个线程完成了自己的任务(工作)后，或是线程在运 行中出现异常情况而须被强行终止时，由终止线程通过调用 相应的函数(或系统调用)对它执行终止操作。但有些线程(主 要是系统线程)，它们一旦被建立起来之后，便一直运行下 去而不被终止。在大多数的OS中，线程被中止后并不立即释 放它所占有的资源，只有当进程中的其它线程执行了分离函 数后，被终止的线程才与资源分离，此时的资源才能被其它 线程利用。</p>
<h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><h3 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h3><h5 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h5><p>一般来说，处理机调度最常用的是低级调度，也称为进程调度，进程调度的主要功能是根据某种算法，决定就绪队列中的哪个进程获得处理机。高级调度又称为作业调度，其主要功能是根据某种算法决定将外存上处于后备队列中哪几个作业调入内存，并为他们创建进程，分配必要的资源，并将他们放入就绪队列。</p>
<h4 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h4><h5 id="处理机调度算法的共同目标"><a href="#处理机调度算法的共同目标" class="headerlink" title="处理机调度算法的共同目标"></a>处理机调度算法的共同目标</h5><ul>
<li>资源利用率</li>
<li>公平性</li>
</ul>
<p>公平性是指应使诸进程都获得合理的CPU</p>
<p>时间，不会发生进程饥饿现象。公平性是相对的，对相同类</p>
<p>型的进程应获得相同的服务；但对于不同类型的进程，由于</p>
<p>其紧急程度或重要性的不同，则应提供不同的服务。</p>
<ul>
<li>平衡性</li>
</ul>
<p>由于在系统中可能具有多种类型的进程，</p>
<p>有的属于计算型作业，有的属于I/O型。为使系统中的CPU和</p>
<p>各种外部设备都能经常处于忙碌状态，调度算法应尽可能保</p>
<p>持系统资源使用的平衡性</p>
<ul>
<li>策略强制执行</li>
</ul>
<p>对所制订的策略其中包括安全策略，</p>
<p>只要需要，就必须予以准确地执行，即使会造成某些工作的</p>
<p>延迟也要执行</p>
<h5 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h5><ul>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高</li>
</ul>
<h5 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h5><ul>
<li>响应时间快。</li>
<li>均衡性。</li>
</ul>
<h5 id="实时系统的目标"><a href="#实时系统的目标" class="headerlink" title="实时系统的目标"></a>实时系统的目标</h5><ul>
<li>截止时间的保证。</li>
<li>可预测性</li>
</ul>
<h3 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h3><h4 id="批处理系统中的作业"><a href="#批处理系统中的作业" class="headerlink" title="批处理系统中的作业"></a>批处理系统中的作业</h4><ul>
<li>作业和作业步</li>
<li>作业控制块</li>
</ul>
<p>为了管理和调度作业，在多道批处理系统中，为每个作</p>
<p>业设置了一个作业控制块JCB，它是作业在系统中存在的标</p>
<p>志，其中保存了系统对作业进行管理和调度所需的全部信息。</p>
<p>通常在JCB中包含的内容有：作业标识、用户名称、用户账</p>
<p>号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、</p>
<p>作业状态、调度信息(优先级、作业运行时间)、资源需求(预</p>
<p>计运行时间、要求内存大小等)、资源使用情况等。</p>
<ul>
<li>作业运行的三个阶段和三种状态</li>
</ul>
<h4 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h4><p>作业调度的主要任务是，根据JCB中的信息，检查系统</p>
<p>中的资源能否满足作业对资源的需求，以及按照一定的调度</p>
<p>算法，从外存的后备队列中选取某些作业调入内存，并为它</p>
<p>们创建进程、分配必要的资源。然后再将新创建的进程排在</p>
<p>就绪队列上等待调度。因此，也把作业调度称为接纳调度</p>
<p>(Admission Scheduling)。在每次执行作业调度时，都需做出</p>
<p>以下两个决定。</p>
<ol>
<li><p>接纳多少个作业</p>
</li>
<li><p>接纳哪些作业</p>
</li>
</ol>
<h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h4><p>FCFS是最简单的调度算法，该算法既可用于作业调度，</p>
<p>也可用于进程调度。当在作业调度中采用该算法时，系统将</p>
<p>按照作业到达的先后次序来进行调度，或者说它是优先考虑</p>
<p>在系统中等待时间最长的作业，而不管该作业所需执行时间</p>
<p>的长短，从后备作业队列中选择几个最先进入该队列的作业，</p>
<p>将它们调入内存，为它们分配资源和创建进程。然后把它放</p>
<p>入就绪队列。</p>
<h4 id="短作业优先-SJF-调度算法"><a href="#短作业优先-SJF-调度算法" class="headerlink" title="短作业优先(SJF)调度算法"></a>短作业优先(SJF)调度算法</h4><p> 短作业优先算法</p>
<p>SJF算法是以作业的长短来计算优先级，作业越短，其</p>
<p>优先级越高。作业的长短是以作业所要求的运行时间来衡量</p>
<p>的。SJF算法可以分别用于作业调度和进程调度。在把短作</p>
<p>业优先调度算法用于作业调度时，它将从外存的作业后备队</p>
<p>列中选择若干个估计运行时间最短的作业，优先将它们调入</p>
<p>内存运行。</p>
<p> 短作业优先算法的缺点</p>
<p>(1) 必须预知作业的运行时间。在采用这种算法时，要</p>
<p>先知道每个作业的运行时间。即使是程序员也很难准确估计</p>
<p>作业的运行时间，如果估计过低，系统就可能按估计的时间</p>
<p>终止作业的运行，但此时作业并未完成，故一般都会偏长估</p>
<p>计。</p>
<p>(2) 对长作业非常不利，长作业的周转时间会明显地增</p>
<p>长。更严重的是，该算法完全忽视作业的等待时间，可能使</p>
<p>作业等待时间过长，出现饥饿现象。</p>
<p>(3) 在采用FCFS算法时，人—机无法实现交互。</p>
<p>(4) 该调度算法完全未考虑作业的紧迫程度，故不能保</p>
<p>证紧迫性作业能得到及时处理。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>在批处理系统中，FCFS算法所考虑的只是作业的等待</p>
<p>时间，而忽视了作业的运行时间。而SJF算法正好与之相反，</p>
<p>只考虑作业的运行时间，而忽视了作业的等待时间。高响应</p>
<p>比优先调度算法则是既考虑了作业的等待时间，又考虑作业</p>
<p>运行时间的调度算法，因此既照顾了短作业，又不致使长作</p>
<p>业的等待时间过长，从而改善了处理机调度的性能、<br>$$<br>Rp=等待时间+要求服务时间/要求服务时间<br>$$</p>
<h3 id="进-程-调-度"><a href="#进-程-调-度" class="headerlink" title="进 程 调 度"></a>进 程 调 度</h3><h4 id="进程调度的任务"><a href="#进程调度的任务" class="headerlink" title="进程调度的任务"></a>进程调度的任务</h4><p>进程调度的任务主要有三：</p>
<p>(1) 保存处理机的现场信息。</p>
<p>(2) 按某种算法选取进程。</p>
<p>(3) 把处理器分配给进程。</p>
<h4 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h4><p>为了实现进程调度，在进程调度机制中，应具有如下三</p>
<p>个基本部分</p>
<p>(1) 排队器。</p>
<p>(2) 分派器。</p>
<p>(3) 上下文切换器。</p>
<h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><h5 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h5><p>在采用这种调度方式时，一旦把处理机分配给某进程后，</p>
<p>就一直让它运行下去，决不会因为时钟中断或任何其它原因</p>
<p>去抢占当前正在运行进程的处理机，直至该进程完成，或发</p>
<p>生某事件而被阻塞时，才把处理机分配给其它进程。</p>
<h5 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h5><p>这种调度方式允许调度程序根据某种原则，去暂停某个</p>
<p>正在执行的进程，将已分配给该进程的处理机重新分配给另</p>
<p>一进程。在现代OS中广泛采用抢占方式，这是因为：对于批</p>
<p>处理机系统，可以防止一个长进程长时间地占用处理机，以</p>
<p>确保处理机能为所有进程提供更为公平的服务。在分时系统</p>
<p>中，只有采用抢占方式才有可能实现人—机交互。在实时系</p>
<p>统中，抢占方式能满足实时任务的需求。但抢占方式比较复</p>
<p>杂，所需付出的系统开销也较大。</p>
<h4 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h4><p>在轮转(RR)法中，系统将所有的就绪进程按FCFS策略</p>
<p>排成一个就绪队列。系统可设置每隔一定时间(如30 ms)便产</p>
<p>生一次中断，去激活进程调度程序进行调度，把CPU分配给</p>
<p>队首进程，并令其执行一个时间片。当它运行完毕后，又把</p>
<p>处理机分配给就绪队列中新的队首进程，也让它执行一个时</p>
<p>间片。这样，就可以保证就绪队列中的所有进程在确定的时</p>
<p>间段内，都能获得一个时间片的处理机时间。</p>
<h4 id="优先级调度算法-1"><a href="#优先级调度算法-1" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><h5 id="静态优先级"><a href="#静态优先级" class="headerlink" title="静态优先级"></a>静态优先级</h5><p>静态优先级是在创建进程时确定的，在进程的整个运行</p>
<p>期间保持不变。优先级是利用某一范围内的一个整数来表示</p>
<p>的，例如0～255中的某一整数，又把该整数称为优先数。确</p>
<p>定进程优先级大小的依据有如下三个：</p>
<p>(1) 进程类型。</p>
<p>(2) 进程对资源的需求。</p>
<p>(3) 用户要求。</p>
<h5 id="动态优先级"><a href="#动态优先级" class="headerlink" title="动态优先级"></a>动态优先级</h5><p>动态优先级是指在创建进程之初，先赋予其一个优先级，</p>
<p>然后其值随进程的推进或等待时间的增加而改变，以便获得</p>
<p>更好的调度性能。</p>
<h4 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h4><h4 id="多级反馈队列-multileved-feedback-queue-调度算法"><a href="#多级反馈队列-multileved-feedback-queue-调度算法" class="headerlink" title="多级反馈队列(multileved feedback queue)调度算法"></a>多级反馈队列(multileved feedback queue)调度算法</h4><p>(1) 设置多个就绪队列</p>
<p>(2) 每个队列都采用FCFS算法。当新进程进入内存后，</p>
<p>首先将它放入第一队列的末尾，按FCFS原则等待调度。当</p>
<p>轮到该进程执行时，如它能在该时间片内完成，便可撤离系</p>
<p>统。否则，即它在一个时间片结束时尚未完成，调度程序将</p>
<p>其转入第二队列的末尾等待调度；如果它在第二队列中运行</p>
<p>一个时间片后仍未完成，再依次将它放入第三队列，……，</p>
<p>依此类推。当进程最后被降到第n队列后，在第n队列中便采</p>
<p>取按RR方式运行。</p>
<p>(3) 按队列优先级调度。调度程序首先调度最高优先级</p>
<p>队列中的诸进程运行，仅当第一队列空闲时才调度第二队列</p>
<p>中的进程运行；换言之，仅当第1～(i-1)所有队列均空时，才</p>
<p>会调度第i队列中的进程运行。如果处理机正在第i队列中为</p>
<p>某进程服务时又有新进程进入任一优先级较高的队列，此时</p>
<p>须立即把正在运行的进程放回到第i队列的末尾，而把处理机</p>
<p>分配给新到的高优先级进程。</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/duoji.png" class title="This is an image">

<h3 id="实-时-调-度"><a href="#实-时-调-度" class="headerlink" title="实 时 调 度"></a>实 时 调 度</h3><h4 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h4><ul>
<li>提供必要的信息</li>
<li>系统处理能力强</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制</li>
</ul>
<h4 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h4><ul>
<li><p>非抢占式调度算法</p>
</li>
<li><p>抢占式调度算法</p>
</li>
</ul>
<h4 id="最早截止时间优先EDF"><a href="#最早截止时间优先EDF" class="headerlink" title="最早截止时间优先EDF"></a>最早截止时间优先EDF</h4><h4 id="最低松弛度优先LLF"><a href="#最低松弛度优先LLF" class="headerlink" title="最低松弛度优先LLF"></a>最低松弛度优先LLF</h4><h3 id="死-锁-概-述"><a href="#死-锁-概-述" class="headerlink" title="死 锁 概 述"></a>死 锁 概 述</h3><h4 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h4><p>可重用性资源和消耗性资源</p>
<p>可抢占性资源和不可抢占性资源</p>
<h4 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h4><p>竞争不可抢占性资源引起死锁</p>
<p>竞争可消耗资源引起死锁</p>
<p>进程推进顺序不当引起死锁</p>
<h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><p>(1) 互斥条件。</p>
<p>(2) 请求和保持条件。</p>
<p>(3) 不可抢占条件。</p>
<p>(4) 循环等待条件</p>
<h3 id="预-防-死-锁"><a href="#预-防-死-锁" class="headerlink" title="预 防 死 锁"></a>预 防 死 锁</h3><img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/yufang.png" class title="This is an image">

<h3 id="避-免-死-锁"><a href="#避-免-死-锁" class="headerlink" title="避 免 死 锁"></a>避 免 死 锁</h3><p>利用银行家算法避免死锁</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/sisuo.png" class title="This is an image">

<h3 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h3><h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h3><img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/cunchuqi.png" class title="This is an image">

<h3 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2 程序的装入和链接"></a>4.2 程序的装入和链接</h3><p>将用户源程序变为可在内存中执行的程序的步骤：</p>
<p><strong>编译</strong>：由编译程序将用户源代码编译成若干个目标模块<br> <strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及它们所需要的库函数链接在一起，形成一个完整的装入模块<br> <strong>装入</strong>：由装入程序将装入模块装入内存，构造PCB，形成进程(使用物理地址)</p>
<p>在多道程序环境下，要使程序运行，必须为之先建立进程。创建进程的第一件事是将程序和数据装入内存。</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/guochen.png" class title="This is an image">

<h4 id="4-2-1-程序的装入"><a href="#4-2-1-程序的装入" class="headerlink" title="4.2.1 程序的装入"></a>4.2.1 程序的装入</h4><h5 id="1-绝对装入方式"><a href="#1-绝对装入方式" class="headerlink" title="1.绝对装入方式"></a>1.绝对装入方式</h5><p> 在编译时，如果知道程序驻留在内存的什么位置，那么编译程序将产生绝对地址的目标代码。<br> 程序中的逻辑地址与实际内存地址完全相同，无需对程序和数据的地址进行变换。<br> <strong>优点</strong>：装入过程简单。<br> <strong>缺点</strong>：过于依赖硬件结构，不便多道程序系统。 </p>
<h5 id="2-静态重定位装入方式"><a href="#2-静态重定位装入方式" class="headerlink" title="2.静态重定位装入方式"></a>2.静态重定位装入方式</h5><ul>
<li>在多道程序环境下，目标模块的起始地址通常从0开始，程序中的其它地址都是相对于起始地址计算的；</li>
<li>因此应采用可重定位装入方式，根据内存的实际情况，将装入模块装入到内存的适当位置。</li>
</ul>
<p>在程序执行之前由专门设计的重定位装配程序一次性实现逻辑地址到物理地址的转换。<br> <strong>优点</strong>：不需硬件支持，可以装入多道程序。<br> <strong>缺点</strong>：一个程序通常需要占用连续的内存空间；程序装入内存后不能移动。</p>
<h5 id="3-动态重定位装入方式"><a href="#3-动态重定位装入方式" class="headerlink" title="3.动态重定位装入方式"></a>3.动态重定位装入方式</h5><ul>
<li>程序装入内存后，并不立即实施地址变换，而是把这种地址转换推迟到程序真正运行时才进行；</li>
<li>装入内存后仍是相对地址；</li>
<li>应设置一个重定位寄存器。</li>
</ul>
<p>在程序执行过程中，每次访问内存之前将程序地址变换为内存地址，这种变换是依靠硬件地址变换机构实现的。</p>
<p><strong>优点</strong>：OS可以将一个程序分散存放于不连续的内存空间，可以移动程序。<br> <strong>缺点</strong>：需要硬件支持，OS实现较复杂。是虚拟存储的基础。</p>
<h4 id="4-2-2-程序的链接"><a href="#4-2-2-程序的链接" class="headerlink" title="4.2.2 程序的链接"></a>4.2.2 程序的链接</h4><h5 id="1-静态链接："><a href="#1-静态链接：" class="headerlink" title="1.静态链接："></a>1.静态链接：</h5><p><strong>定义</strong>：在程序运行前，将目标模块及所需的库函数链接成一个完整的装配模块，以后不再拆开。<br> 静态链接是在生成可执行文件时进行的。<br> 事先进行链接，以后不再拆开。</p>
<h5 id="2-装入时动态链接："><a href="#2-装入时动态链接：" class="headerlink" title="2.装入时动态链接："></a>2.装入时动态链接：</h5><p><strong>定义</strong>：指将用户源程序编译后所得的一组目标模块，在装入内存时，采用边装入边链接的链接方式。<br> 在装入或运行时进行链接。通常被链接的共享代码称为动态链接库(DLL, Dynamic-Link Library)或共享库(shared library)。<br> 边装入边链接。<br> <strong>优点：</strong><br> (1) 便于模块的修改和更新；<br> (2) 便于实现对目标模块的共享。</p>
<h5 id="3-运行时动态链接："><a href="#3-运行时动态链接：" class="headerlink" title="3.运行时动态链接："></a>3.运行时动态链接：</h5><p><strong>定义</strong>：指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行链接。<br> 边执行边链接！<br> <strong>优点：</strong><br> 加快装入过程、节省内存空间</p>
<h3 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h3><p> 连续分配方式，是指为一个用户程序分配一个连续的内存空间。 </p>
<p> 固定分区存储管理中存储保护用 下限寄存器值≤绝对地址≤上限寄存器值 关系式进行核对。  绝对地址＝下限寄存器+逻辑地址 </p>
<p> 可变分区存储管理  判断到“逻辑地址＞限长寄存器值”时，形成—个“地址越界”的程序性中断事件。  绝对地址＝基址寄存器值＋逻辑地址 </p>
<h4 id="4-3-1-单一连续分配"><a href="#4-3-1-单一连续分配" class="headerlink" title="4.3.1 单一连续分配"></a>4.3.1 单一连续分配</h4><p>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。<br> 最简单，适用于单用户、单任务的OS。<br> <strong>优点</strong>：易于管理。<br> <strong>缺点</strong>：</p>
<ul>
<li>对要求内存空间少的程序，造成内存浪费；</li>
<li>程序全部装入，很少使用的程序部分也占用内存。</li>
</ul>
<h4 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2 固定分区分配"></a>4.3.2 固定分区分配</h4><h5 id="1、基本原理及技术"><a href="#1、基本原理及技术" class="headerlink" title="1、基本原理及技术"></a>1、基本原理及技术</h5><p>系统提前把内存分为一些大小相等或不等的分区(partition)，每个进程占用一个分区。操作系统占用其中一个分区。<br> <strong>特点</strong>：</p>
<ul>
<li>适用于多道程序系统和分时系统。</li>
<li>支持多个程序并发执行</li>
</ul>
<p><strong>问题</strong>：可能存在内碎片。</p>
<p>内碎片：分区之内未被利用的空间<br> 外碎片：分区之间难以利用的空闲分区（通常是小空闲分区）</p>
<h5 id="划分分区的方法"><a href="#划分分区的方法" class="headerlink" title="划分分区的方法"></a>划分分区的方法</h5><p><strong>分区大小相等</strong>：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。缺乏灵活性。<br> <strong>分区大小不等</strong>：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><strong>优点：</strong> 易于实现，开销小。</li>
<li><strong>缺点：</strong><br> 内碎片造成浪费<br> 分区总数固定，限制了并发执行的程序数目。</li>
<li>可以和覆盖、交换技术配合使用。</li>
<li>采用的数据结构：分区表－记录分区的大小和使用情况</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>当有一用户程序要装入时，由内存分配程序检索该表；</li>
<li>从中找出一个能满足要求的、尚未分配的分区；</li>
<li>将之分配给该程序，然后将该表项中的状态置为“已分配”；</li>
<li>若未找到大小足够的分区，则拒绝为该用户程序分配内存。</li>
</ul>
<h4 id="4-3-3-动态-可变-分区分配"><a href="#4-3-3-动态-可变-分区分配" class="headerlink" title="4.3.3 动态(可变)分区分配"></a>4.3.3 动态(可变)分区分配</h4><p><strong>动态创建分区：</strong><br> 在装入程序时按其初始要求分配；<br> 或在其执行过程中通过系统调用进行分配或改变分区大小。<br> <strong>优点：</strong> 没有内碎片。<br> <strong>缺点：</strong> 有外碎片。</p>
<h5 id="1-分区分配中的数据结构"><a href="#1-分区分配中的数据结构" class="headerlink" title="1.分区分配中的数据结构"></a>1.分区分配中的数据结构</h5><p> <strong>空闲分区表：</strong> 记录每个空闲分区的情况。每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。 </p>
<p> <strong>空闲分区链</strong></p>
<h5 id="2-分区分配算法"><a href="#2-分区分配算法" class="headerlink" title="2.分区分配算法"></a>2.分区分配算法</h5><h5 id="基于顺序搜索的分区分配算法："><a href="#基于顺序搜索的分区分配算法：" class="headerlink" title="基于顺序搜索的分区分配算法："></a>基于顺序搜索的分区分配算法：</h5><p> <strong>(1) 首次适应算法FF(First Fit)</strong><br> （最先匹配法(first-fit)）首址递增排列。<br> <strong>优点：</strong> 优先利用内存低址部分。<br> <strong>缺点：</strong> 低址部分不断划分，产生小碎片；每次查找从低址部分开始，增加了查找的开销。 </p>
<p><strong>(2) 循环首次适应算法NF(Next Fit)</strong><br> （下次匹配法(next-fit)）</p>
<p>为实现算法，需要：</p>
<ul>
<li>设置一起始查寻指针</li>
<li>采用循环查找方式</li>
</ul>
<p><strong>优点：</strong> 使内存空闲分区分布均匀，减少查找的开销<br> <strong>缺点：</strong> 缺乏大的空闲分区</p>
<p> <strong>(3) 最佳适应算法BF(Best Fit)</strong><br> （最佳匹配法(best-fit) ）<br> 空闲区按大小递增排列！<br> <strong>缺点：</strong> 产生许多难以利用的小空闲区（外碎片 </p>
<p><strong>(4) 最差适应算法WF(Worst Fit)</strong><br> （最坏匹配法(worst-fit) ）<br> 空闲区按大小递减排列！<br> 不会留下太多的小空闲分区；<br> 但较大的空闲分区不被保留。</p>
<ul>
<li><strong>首次适应算法</strong><br> 将地址最小的够用的空间分配出去</li>
<li><strong>下次适应算法</strong><br> 从上次分配位置开始搜索<br> 将地址最小的够用的空间分配出去</li>
<li><strong>最佳适应算法</strong><br> 将够用的长度最小的空间分配出去</li>
<li><strong>最差适应算法</strong><br> 将够用的长度最大的空间分配出去</li>
</ul>
<h5 id="基于索引搜索的分区分配算法"><a href="#基于索引搜索的分区分配算法" class="headerlink" title="基于索引搜索的分区分配算法"></a>基于索引搜索的分区分配算法</h5><p>当系统很大时，系统中的内存分区可能会很多，相应的空闲分区表或链就可能很长，这时采用顺序搜索分区方法可能会很慢。<br> <strong>1.快速适应算法：</strong><br> 将空闲分区，按其容量大小，进行分类，对于每一类的所有空闲分区，单独设立一个空闲分区链表</p>
<p><strong>2.伙伴系统：</strong><br> 分区大小均为2的k次幂，将空闲分区按分区的大小进行分类，并单独设立一个空闲分区双向链表。<br> <strong>Buddy（伙伴的定义）</strong><br> 满足以下三个条件的称为伙伴：<br> 1）两个块大小相同；<br> 2）两个块地址连续；<br> 3）两个块必须是同一个大块中分离出来的；</p>
<ul>
<li><p>一种经典的内存分配方案</p>
</li>
<li><p>主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块。</p>
</li>
<li><p>算法：</p>
<p>首先将整个可用空间看作一块： 2^U</p>
<p>假设进程申请的空间大小为 s，如果满足 2^U-1&lt;s&lt;=2^U   则分配整个块<br>否则，将块划分为两个大小相等的伙伴，大小为 2^U-1   一直划分下去直到产生大于或等于 s 的最小块                                         </p>
</li>
</ul>
<p><strong>分配算法</strong><br> 当用户申请大小为n的内存请求,在可利用空闲表上寻找结点大小与n相匹配的表</p>
<ul>
<li>表非空，分配表中第一个内存块</li>
<li>表空，从更大的非空表中查找，直到找到一个空闲块，切割出所需要大小的块</li>
<li>未分配部分，插入到相应的空闲表中</li>
</ul>
<p><strong>回收算法</strong><br> 判断伙伴是否为空闲块(回收算法需了解释放的块大小)</p>
<ul>
<li>否，将释放的空闲块插入到相应表中；</li>
<li>是，找到伙伴，伙伴出队，合并</li>
<li>合并后，判断合并后的块的伙伴是否是空闲块，如果是，继续合并成更大的块。依次重复，直到归并后的块的伙伴不空闲。再插入到相应的空闲块表中。</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>可以很快找到空闲块；</li>
<li>避免了外碎片问题；</li>
<li>申请内存总是以2n字节满足要求，存在内碎片；</li>
<li>申请/释放可能会导致连续切块/合并，影响系统效率；</li>
</ul>
<p><strong>3.哈希算法：</strong><br> 构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。</p>
<h4 id="3-分区分配操作"><a href="#3-分区分配操作" class="headerlink" title="3.分区分配操作"></a>3.分区分配操作</h4><p> 设请求的分区大小为u.size，<br> 表中每个空闲分区的大小表示为m.size，<br> 若m.size- u.size&lt;=size(最小阈值)，<br> 将整个分区分配给请求者，<br> 否则从分区中按请求的大小划出一块内存空间分配，<br> 余下部分留在空闲链中，将分配区首址返回给调用者。</p>
<h4 id="4-回收内存"><a href="#4-回收内存" class="headerlink" title="4.回收内存"></a>4.回收内存</h4><p> 进程运行完毕释放内存时，系统根据回收区首址，在空闲分区链(表)中找到相应插入点；<br> <strong>此时可能有四种情况：</strong></p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/huishou.png" class title="This is an image">

<p> (1) 回收区与插入点的前一个分区F1邻接：将回收区与F1合并，修改F1的表项的分区大小<br> (2) 回收区与插入点的后一个分区F2邻接：将回收区与F2合并，修改F2的表项的首址、分区大小<br> (3) 回收区与插入点的前后两个分区F1、F2邻接：将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和<br> (4) 回收区既不与F1邻接，又不与F2邻接：为回收区单独建立新表项，填写回收区的首址与大小，根据其首址插到空闲链中的适当位置 </p>
<h4 id="4-3-4可重定位分区分配"><a href="#4-3-4可重定位分区分配" class="headerlink" title="4.3.4可重定位分区分配"></a>4.3.4可重定位分区分配</h4><h5 id="1-动态重定位的引入"><a href="#1-动态重定位的引入" class="headerlink" title="1. 动态重定位的引入"></a>1. 动态重定位的引入</h5><p><strong>解决碎片：</strong> 将内存中的所有作业进行移动，使它们全部邻接，这样可把原来分散的小分区拼接成大分区，这种方法称为“拼接”或“紧凑”。<br> <strong>缺点：</strong> 用户程序在内存中的地址发生变化，必须重定位。</p>
<h5 id="2-动态重定位的实现"><a href="#2-动态重定位的实现" class="headerlink" title="2. 动态重定位的实现"></a>2. 动态重定位的实现</h5><p><strong>内存紧缩(compaction)：</strong> 将各个占用分区向内存一端移动。使各个空闲分区聚集在另一端，然后将各个空闲分区合并成为一个空闲分区。<br> <strong>优点：</strong> 消除外碎片。<br> <strong>缺点：</strong></p>
<ul>
<li>对占用分区进行内存数据搬移占用CPU时间；</li>
<li>重定位需要硬件支持。</li>
</ul>
<p><strong>紧缩时机：</strong></p>
<ul>
<li>每个分区释放后；</li>
<li>内存分配找不到满足条件的空闲分区时。</li>
</ul>
<h5 id="3-动态重定位分区分配算法"><a href="#3-动态重定位分区分配算法" class="headerlink" title="3. 动态重定位分区分配算法"></a>3. 动态重定位分区分配算法</h5><p>动态重定位分区分配算法与动态分区分配算法基本相同，差别在于增加了紧凑的功能。</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/dongtai.png" class title="This is an image">


<p> <strong>可重定位分区分配方式主要特点</strong></p>
<ul>
<li>可以充分利用存储区中的“零头/碎片”，提高主存的利用率。</li>
<li>但拼接/紧缩会使系统开销加大</li>
</ul>
<p><strong>分区的存储保护</strong><br> （1）界限寄存器方法</p>
<ul>
<li>上下界寄存器方法</li>
<li>基址、限长寄存器方法</li>
</ul>
<p>（2）存储保护键方法</p>
<ul>
<li>给每个分区分配一个单独的保护键，它相当于一把锁。</li>
<li>进入系统的每个作业赋予一个保护键，它相当于一把钥匙。</li>
<li>当作业运行时，检查钥匙和锁是否匹配，如果不匹配，则系统发出保护性中断信号，停止作业运行。</li>
</ul>
<p><strong>在可变分区管理方式下，为什么要采用移动技术?为什么在等待外设传输信息的作业不能移动?</strong></p>
<ul>
<li>采用移动技术可把分散的空闲区集中起来，以容纳新的作业。这样提高了主存的利用率，还能为作业动态扩充主存空间提供方便。</li>
<li>因为外设与主存储器之间的信息交换是按确定了的主存绝对地址进行传输的，如果这时改变了作业的存放区域，则作业就得不到从外围设备传送来的信息，或不能把正确的信息传送到外围设备。</li>
</ul>
<p><strong>内存“扩充”技术</strong></p>
<ul>
<li>内存紧缩技术（例如：可变分区）</li>
<li>覆盖技术 overlaying</li>
<li>交换技术 swapping</li>
<li>虚拟存储技术 virtual memory</li>
</ul>
<p><strong>覆盖技术</strong></p>
<ul>
<li>解决的问题 → 程序大小超过物理内存总和</li>
<li>程序执行过程中，程序的不同部分在内存中相互替代<br> →按照其自身的逻辑结构，使那些不会同时执行的程序段共享同一块内存区域<br> →要求程序各模块之间有明确的调用结构</li>
<li>程序员声明覆盖结构，操作系统完成自动覆盖</li>
</ul>
<h3 id="4-4-对换（Swapping）"><a href="#4-4-对换（Swapping）" class="headerlink" title="4.4 对换（Swapping）"></a>4.4 对换（Swapping）</h3><p>多道程序环境下存在的问题：</p>
<ul>
<li>阻塞进程占据大量内存空间</li>
<li>许多作业在外存而不能进入内存运行</li>
</ul>
<p>所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调到外存上，以便腾出足够的内存空间，再把已具备运行条件的程序和数据，调入内存。</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><ul>
<li>整体对换(或进程对换)：以整个进程为单位</li>
<li>页面对换或分段对换：以页或段为单位</li>
</ul>
<h4 id="实现进程对换，系统必须具备的功能"><a href="#实现进程对换，系统必须具备的功能" class="headerlink" title="实现进程对换，系统必须具备的功能"></a>实现进程对换，系统必须具备的功能</h4><ul>
<li>对换空间的管理</li>
<li>进程的换出</li>
<li>进程的换</li>
</ul>
<h4 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h4><h4 id="进程的换出与换入"><a href="#进程的换出与换入" class="headerlink" title="进程的换出与换入"></a>进程的换出与换入</h4><ul>
<li>进程的换出<br> 过程：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区。</li>
<li>进程的换入<br> 系统应定时查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将换出最久的进程作为换入进程，将之换入。</li>
</ul>
<h4 id="什么是覆盖技术-什么是对换技术"><a href="#什么是覆盖技术-什么是对换技术" class="headerlink" title="什么是覆盖技术?什么是对换技术?"></a>什么是覆盖技术?什么是对换技术?</h4><ul>
<li>覆盖技术：把用户作业分成若干段，使主段成为作业执行过程中经常使用的信息，其他段不同时工作。作业执行时，把主段常驻主存区，其他段轮流装入覆盖区执行之。</li>
<li>对换技术：让多个用户作业轮流进入主存器(转入、转出)执行。</li>
<li>覆盖主要在同一个作业或同一个进程内进行。</li>
<li>对换主要是在进程或作业之间进行。覆盖只能覆盖那些与覆盖程序段无关的程序段。</li>
</ul>
<h3 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h3><h4 id="4-5-1-分页存储管理的基本方法"><a href="#4-5-1-分页存储管理的基本方法" class="headerlink" title="4.5.1 分页存储管理的基本方法"></a>4.5.1 分页存储管理的基本方法</h4><p>将程序的逻辑地址空间划分为固定大小的页;</p>
<p>物理内存划分为固定大小的块（页架）;</p>
<p>程序加载时，分配其所需的所有页，这些页不必连续。需要CPU的硬件支持</p>
<p><strong>优点：</strong></p>
<ul>
<li>没有外碎片，每个内碎片不超过页大小。</li>
<li>一个程序不必连续存放。</li>
<li>便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。</li>
</ul>
<p><strong>缺点：</strong><br> 程序全部装入内存。</p>
<h5 id="1-页面和物理块"><a href="#1-页面和物理块" class="headerlink" title="1.页面和物理块"></a>1.页面和物理块</h5><ul>
<li>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片称为页，并为各页加以编号，从0开始。</li>
<li>同时把内存空间分成与页面相同大小的若干个存储块，称为块。</li>
<li>在为进程分配内存时，以块为单位将进程的若干个页分别装入到多个可以不相邻的物理块中。</li>
<li>进程的最后一页经常装不满而形成“页内碎片”。</li>
</ul>
<h5 id="2-地址结构"><a href="#2-地址结构" class="headerlink" title="2. 地址结构"></a>2. 地址结构</h5><p> <strong>号与页内偏移的计算</strong><br> 若给定一个逻辑地址空间中的地址为A，页面大小为L，则:<br> 页号： P=INT[A/L]<br> 页内地址： d=[A] MOD L </p>
<h4 id="4-5-2-地址变换机构"><a href="#4-5-2-地址变换机构" class="headerlink" title="4.5.2 地址变换机构"></a>4.5.2 地址变换机构</h4><h5 id="1-基本的地址变换机构"><a href="#1-基本的地址变换机构" class="headerlink" title="1. 基本的地址变换机构"></a>1. 基本的地址变换机构</h5><p>实现从逻辑地址到物理地址的转换，其任务是借助于页表，将逻辑地址中的页号转换为内存中的物理块号。</p>
<ul>
<li>页表可以由一组专门的寄存器来实现，一个页表项用一个寄存器。但寄存器成本高，系统页表可能很大，所以页表大多常驻内存。</li>
<li>在系统中只设置一个<strong>页表寄存器PTR</strong>，在其中存放页表在内存中的始址和页表的长度。</li>
<li>在分页系统中，允许进程的每一页离散地存储在内存的任一存储块中，为方便查找，系统为每一进程建立一张页面映像表，简称页表。</li>
<li>页表实现了从页号到物理块号的地址映射。</li>
<li>在页表表项中常设置一存取控制字段，对存储块内容加以保护。</li>
</ul>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/yebiao.png" class title="This is an image">

<p> <strong>地址转换步骤</strong><br> <strong>1.当逻辑地址为十进制时：</strong><br> 求出逻辑地址的页号 = 逻辑地址 / 页面大小<br> 求出页内偏移量 = 逻辑地址 % 页面大小<br> 用页号查页表，得到块号；<br> 求出物理地址 = 块号 * 页面大小 + 页内偏移<br> <strong>2.当逻辑地址为十六进制/八进制/二进制时:</strong><br> 把逻辑地址转为二进制；<br> 按页的大小分离出页号和页内偏移量（ 高位部分为页号，低位部分为页内偏移量 ）；<br> 以页号查页表，得到物理地址的块号；<br> 将逻辑地址的页内偏移量直接复制到物理地址的块内偏移量上；<br> 把块号转为二进制，从而得出物理地址，再转回16/8进制。 </p>
<h5 id="2-具有快表的地址变换机构"><a href="#2-具有快表的地址变换机构" class="headerlink" title="2.具有快表的地址变换机构"></a>2.具有快表的地址变换机构</h5><p>CPU在每存取一个数据时，需要两次访问内存：</p>
<ul>
<li>第一次：访问页表，找到指定页的物理块号，将块号与页内偏移量拼接形成物理地址。</li>
<li>第二次：从第一次所得地址中获得所需数据，或向此地址中写入数据。 处理速度降低！</li>
</ul>
<p>解决方法：在地址变换机构中，增设一个具有并行查寻能力的特殊高速缓冲寄存器，称为“联想存储器”或“快表”。</p>
<h4 id="4-5-3-有效访问内存的时间"><a href="#4-5-3-有效访问内存的时间" class="headerlink" title="4.5.3 有效访问内存的时间"></a>4.5.3 有效访问内存的时间</h4><p>T=a<em>（λ+t）+ （1-a）</em>（ λ+2t ）<br> =aλ+at+(1-a)(λ+t)+(1-a)t<br> =aλ+(1-a)(λ+t)+t<br> 其中,a为快表的命中率, λ为快表的访问时间, t为内存的访问时间</p>
<h4 id="4-5-4-两级和多级页表"><a href="#4-5-4-两级和多级页表" class="headerlink" title="4.5.4 两级和多级页表"></a>4.5.4 两级和多级页表</h4><p>现代计算机系统都支持非常大的逻辑地址空间,页表就非常大,需占用较大的地址空间</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/erji.png" class title="This is an image">

<p><strong>反置页表</strong></p>
<ol>
<li>反置页表的引入<br>  在现代计算机系统中，通常允许一个进程的逻辑地址空间非常大，因此就需要有许多的页表项，而因此也会占用大量的内存空间。  引入反置页表，一般页表的页表项是按页号进行排序的，页表项中的内容是物理块号。而反置页表则是为每一个物理块设置一个页表项，并按物理块的编号排序。其中的内容是页号和其所隶属进程的标识符。</li>
<li>地址变换。<br> 利用反置页表进行地址变换时，是根据进程标识符和页号，去检索反置页表。如果检索到与之匹配的页表项，则该页表项(中)的序号i便是该页所在的物理块号，可用该块号与页内地址一起构成物理地址送内存地址寄存器。<br> 在反置页表可能只包含已经调入内存中的页面，并未包含尚未调入内存的页面。因此还必须为每个进程建立一个外部页表。当发现所需之页面不在内存时，因在外部页表中包含了各个页面在外存的物理地址，通过它可将所需之页面调入内存。<br> 当内存容量很大时，也表项的数目还是会非常大的。要利用进程标识符和页号去检索这样大的一个线性表是相当费时的。可利用Hash算法来进行检索，可以很快找到在反置页表中相应页表项，不过可能会出现所谓的“地址冲突”。</li>
</ol>
<h3 id="4-6分段存储管理方式"><a href="#4-6分段存储管理方式" class="headerlink" title="4.6分段存储管理方式"></a>4.6分段存储管理方式</h3><p>如果说推动存储管理方式从固定分区到动态分区分配，进而又发展到分页存储管理方式的主要动力，是提高内存利用率，那么，引入分段存储管理方式的目的，则主要是为了满足用户(程序员)在编程和使用上多方面的要求。</p>
<h4 id="4-6-1分段存储管理方式的引入"><a href="#4-6-1分段存储管理方式的引入" class="headerlink" title="4.6.1分段存储管理方式的引入"></a><strong>4.6.1分段存储管理方式的引入</strong></h4><ol>
<li>方便编程。<br> 通常，用户把自己的作业按照逻辑关系划分为若干个段。程序员们都迫切地需要访问的逻辑地址是由段名(段号)和段内偏移量(段内地址)决定的。</li>
<li>信息共享。<br> 实现对程序和数据的共享时，是以信息的逻辑单位为基础的。分页系统中的“页”只是存放信息的物理单位(块)，并无完整的意义。而段却是信息的逻辑单位，因此可以为该被共享过程建立一个独立的段，极大地简化了共享的实现。</li>
<li>信息保护。<br> 信息保护同样是对信息的逻辑单位进行保护的。在分页系统中，一个函数可能要占用若干个页面，而且其中的第一个和最后一个页面还会装有其它程序段的数据，它们可能有着不同的保护属性。</li>
<li>动态增长。</li>
<li>动态链接。<br> 运行时动态链接要求的是以目标程序(即段)作为链接的基本单位，因此，分段存储管理方式非常适合动态链接。</li>
</ol>
<h4 id="4-6-2-分段系统的基本原理"><a href="#4-6-2-分段系统的基本原理" class="headerlink" title="4.6.2 分段系统的基本原理"></a>4.6.2 分段系统的基本原理</h4><h5 id="1-分段"><a href="#1-分段" class="headerlink" title="1.分段"></a>1.分段</h5><p> 由于整个作业的地址空间是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。 </p>
<h5 id="2-段表"><a href="#2-段表" class="headerlink" title="2.段表"></a>2.段表</h5><ul>
<li>段表可以存放在寄存器中，但更多的是存放在内存中。</li>
<li>段表可以实现从逻辑段到物理内存区的映射。</li>
</ul>
<h5 id="3-地址变换机构"><a href="#3-地址变换机构" class="headerlink" title="3. 地址变换机构"></a>3. 地址变换机构</h5><p>在系统中设置段表寄存器，用于存放段表始址和段表长度，以实现从进程的逻辑地址到物理地址的变换。</p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/duanhao.png" class title="This is an image">

<p> 分页和分段的主要区别。<br> 相似之处：<br> 两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换。<br> 不同：<br> 1）页是信息的物理单位，分页是为了提高内存的利用率。段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。<br> 2）页的大小固定且由系统决定。而段的长度却不固定，决定于用户所编写的程序。<br> 3）分页中用户程序的的逻辑地址空间是一维的，分页完全是系统的行为，只需要一个记忆符即可表示一个地址。而分段中用户程序的逻辑地址空间是二维的，在标识一个地址时，既需给出段名， 又需给出段内地址（正是因为段的大小不固定导致的） </p>
<h4 id="4-6-4段页式存储管理方式"><a href="#4-6-4段页式存储管理方式" class="headerlink" title="4.6.4段页式存储管理方式"></a>4.6.4段页式存储管理方式</h4><p>1  基本原理</p>
<p> 段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成 </p>
<p> 为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。段表的内容与分段系统略有不同，它不再是内存始址和段长，而是页表始址和页表长度。即一个分段对应一个页表。 </p>
<ol start="2">
<li><p>地址变换过程 </p>
<img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/duanye.png" class title="This is an image">

</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="5-1概述"><a href="#5-1概述" class="headerlink" title="5.1概述"></a>5.1概述</h3><p> 虚拟存储器就是使用虚拟技术从逻辑上对存储器进行扩充。 </p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p> 一次性和驻留性严重地降低内存的利用率，显著地减少了系统吞吐量。<br> 研究表明，程序在执行过程中呈现局部性原理。 </p>
<h5 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h5><p> 一条指令被执行后，那么它可能很快会再次被执行 </p>
<h5 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h5><p>若某一存储单元被访问，那么与该存储单元相邻的单元可能也会很快被访问</p>
<p>局部性原理使得虚拟存储技术的实现成为可能。一个程序特别是一个大型程序的一部分装入内存是可以运行的。</p>
<h4 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h4><p> 可以把一个程序分多次装入内存，每次装入当前运行需要使用的部分——多次性；<br> 在程序执行过程中，可以把当前暂不使用的部分换出内存，若以后需要时再换进内存——交换性即非驻留性；<br> 程序在内存中可分段存放，每一段是连续的——离散性。<br> 虚拟存储器还有一个最重要的特征——虚拟性，从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。 </p>
<h4 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h4><p>所谓虚拟存储器，是指仅把程序的一部分装入内存便可运行程序的存储器系统。具体地说，所谓虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。</p>
<p>虚拟存储器并非可以无限大，其容量受外存大小和指令中地址长度两方面的限制。</p>
<h3 id="5-2分页虚拟存储管理方式"><a href="#5-2分页虚拟存储管理方式" class="headerlink" title="5.2分页虚拟存储管理方式"></a>5.2分页虚拟存储管理方式</h3><h4 id="分页虚拟存储管理"><a href="#分页虚拟存储管理" class="headerlink" title="分页虚拟存储管理"></a>分页虚拟存储管理</h4><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>分页虚拟存储管理方式是在分页系统的基础上，增加了请求调页功能、页面置换功能所形成的虚拟存储器系统。<br> 在分页虚拟存储管理时使用的页表，是在原来页表的基础上发展起来的，包括以下内容：物理块号、状态位、访问位、修改位、外存地址 。</p>
<p>状态位P：指示该页是否已经调入内存</p>
<p>访问字段A：用于记录本页在一段时间内被访问次数</p>
<p>修改位M：标识该页在调入内存后是否被修改过，如果未被修改过，在置换该页时，就不需要将该页写回到外存上；如果修改过，则必须重写到外存上。</p>
<p>外存地址：指该页在外存上的地址</p>
<h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>每当要访问的页面不在内存时，便产生一缺页中断，请求操作系统把所缺页面调入内存。，请求操作系统把所缺页面调入内存。缺页中断作为中断，它同样需要经历诸如保护CPU现场环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤。</p>
<h5 id="缺页中断与与一般的中断的区别"><a href="#缺页中断与与一般的中断的区别" class="headerlink" title="缺页中断与与一般的中断的区别"></a>缺页中断与与一般的中断的区别</h5><p>－在指令执行期间产生和处理中断信号。<br> －一条指令在执行期间，可能产生多次缺页中断。</p>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p>在分页存储管理方式中的地址变换机构的基础上，增加了产生和处理缺页中断，以及从内存中换出一页等功能。具体过程：</p>
<ul>
<li>保存当前进程的CPU现场环境，从辅存中找到该页；</li>
<li>查看当前内存是否有空闲空间调入该页，如果有则启动I/O，将该页由辅存调入内存，同时修改页表，再按分页存储管理方式的地址变换过程转换地址；如果内存已满，则按照某种算法选择一页作为淘汰页调出，腾出空间后再调入。当然如果被淘汰的页在内存中已经被修改过，则需将该页写回辅存。</li>
</ul>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><strong>最小物理块数：</strong></p>
<p>能保存进程正常运行所需的最小物理块数，当系统为进程分配的物理块数少于此值时，进程将无法运行</p>
<ul>
<li><p>固定分配</p>
<p>指为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</p>
</li>
<li><p>可变分配：</p>
<p>是指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况适当的增加或减少</p>
</li>
<li><p>全局置换：</p>
<p>如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或者以所有进程的全部物理块为标准，选择一块换出</p>
</li>
<li><p>局部置换：</p>
<p>如果进程在运行中发现缺页，则只能从分配给该进程的N个页面中选出一块换出</p>
</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li><p>固定分配局部置换   </p>
<ul>
<li>缺点：难以确定为每个进程应该分配多少个物理块，太少，则会频繁的出现缺页中断，太多，则内存中的进程数量会减少，进而造成cpu空闲或者其他资源空闲的情况</li>
</ul>
</li>
<li><p>可变分配全局置换   </p>
<ul>
<li>缺点：采用这种策略仅当空闲物理块中的物理块用完，内存中的页才会调出，被调出的页可能是系统中任何一个进程的页，此进程所有拥有的物理块会较少，导致其缺页增加</li>
</ul>
</li>
<li><p> 可变分配局部置换 </p>
</li>
</ul>
<p><strong>物理块分配算法</strong></p>
<ul>
<li><p>平均分配算法</p>
<p>每个进程分配的物理块数量一样</p>
</li>
<li><p>按比例分配算法</p>
<p>按照进程的大小根据比例分配</p>
</li>
<li><p>考虑优先权的分配算法</p>
<p>考虑到线程优先级</p>
</li>
</ul>
<h4 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h4><h5 id="何时调页？"><a href="#何时调页？" class="headerlink" title="何时调页？"></a>何时调页？</h5><ul>
<li><p>预调页策略</p>
<p>将那些预计在不久之后便会被访问的页面预先调入内存</p>
</li>
<li><p>请求调页策略</p>
<p>当发现所需页面不在时，便立即hi提出调页请求</p>
</li>
</ul>
<h5 id="何处调页？"><a href="#何处调页？" class="headerlink" title="何处调页？"></a>何处调页？</h5><ul>
<li>系统如果拥有足够的对换区空间，这时可以全部从对换区调入所需要的页面，但是在进程运行前，需要将所有与该进程有关的文件从文件区拷贝到对换区</li>
<li>系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于他们未被修改，则不必将他们重写到磁盘中，以后在调入时也是从文件区直接调入，对于可能被修改的部分，再将他们换出时必须换出到对换区，以后在需要时从对换区调入</li>
</ul>
<h5 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h5><p>  每当程序所要访问的页面未在内存时(存在位为“0”)，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入缺页中断处理程序。 </p>
<h5 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h5><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h5 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h5><p>－算法：淘汰那些以后永不使用，或者是在最长时间内不再被访问的页<br> －无法实现的，只能作为其它置换算法的衡量标准</p>
<h5 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h5><p>－算法：每次淘汰最先进入内存的页<br> －优点：简单，易于实现<br> －缺点：效率不高，可能产生“抖动”现象</p>
<h5 id="最近最久未使用（LRU）算法"><a href="#最近最久未使用（LRU）算法" class="headerlink" title="最近最久未使用（LRU）算法"></a>最近最久未使用（LRU）算法</h5><p>－算法：淘汰那些在最近一段时间里最久未被使用的一页<br> － LRU算法是较好的一个算法，但是开销太大，要求系统有较多的支持硬件(移位寄存器或栈）</p>
<h5 id="最少使用-Least-Frequently-Used，LFU-置换算法"><a href="#最少使用-Least-Frequently-Used，LFU-置换算法" class="headerlink" title="最少使用(Least Frequently Used，LFU)置换算法"></a>最少使用(Least Frequently Used，LFU)置换算法</h5><p> 在采用LFU算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰页。 </p>
<h5 id="改进型Clock置换算法"><a href="#改进型Clock置换算法" class="headerlink" title="改进型Clock置换算法"></a>改进型Clock置换算法</h5><p>－算法：除了考虑到页面的使用情况外，还增加了置换代价，选择换出页面时，既要是未使用过的页面，又要是未被修改过的页面把同时满足两条件的页面作为首选被淘汰的页。<br> －该算法与简单Clock算法比较，可减少磁盘的I/O操作次数 ，但实现该算法本身的开销将有所增加</p>
<h5 id="页面缓冲算法-Page-Buffering-Algorithm，PBA"><a href="#页面缓冲算法-Page-Buffering-Algorithm，PBA" class="headerlink" title="页面缓冲算法(Page Buffering Algorithm，PBA)"></a>页面缓冲算法(Page Buffering Algorithm，PBA)</h5><p> 影响页面换进换出效率的若干因素</p>
<p>(1) 页面置换算法。(2) 写回磁盘的频率。(3) 读入内存的频率。 </p>
<p> 页面缓冲算法PBAPBA算法的主要特点是：</p>
<p>①显著地降低了页面换进、换出的频率，使磁盘I/O的操作次数大为减少，因而减少了页面换进、换出的开销；②正是由于换入换出的开销大幅度减小，才能使其采用一种较简单的置换策略，如先进先出(FIFO)算法，它不需要特殊硬件的支持，实现起来非常简单。1) 空闲页面链表2) 修改页面链表 </p>
<p> 访问内存的有效时间 </p>
<p> 与基本分页存储管理方式不同，在请求分页管理方式中，内存有效访问时间不仅要考虑访问页表和访问实际物理地址数据的时间，还必须要考虑到缺页中断的处理时间 </p>
<h3 id="抖动和工作集"><a href="#抖动和工作集" class="headerlink" title="抖动和工作集"></a>抖动和工作集</h3><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p>
<p> 同在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁出现缺页，必须请求系统将所缺的页调入内存，这会使在系统排队等待页面调入调出的进程数目增多，造成每个进程的大部分时间都处于页面的换进换出，而几乎不去做任何有效的工作 </p>
<h5 id="预防抖动的方法"><a href="#预防抖动的方法" class="headerlink" title="预防抖动的方法"></a>预防抖动的方法</h5><p>  采取局部置换策略</p>
<p>在页面分配和置换策略中，如果采取的是可变分配方式，则为了预防发生“抖动”，可采取局部置换策略。 </p>
<p>   把工作集算法融入到处理机调度中</p>
<p>当调度程序发现处理机利用率低下时，它将试图从外存调入一个新作业进入内存，来改善处理机的利用率。 </p>
<p> 利用“L=S”准则调节缺页率 </p>
<p> Denning于1980年提出了“L=S”的准则来调节多道程序度，其中L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面所需的时间。如果是L远比S大，说明很少发生缺页，磁盘的能力尚未得到充分的利用；反之，如果是L比S小，则说明频繁发生缺页，缺页的速度已超过磁盘的处理能力。只有当L与S接近时，磁盘和处理机都可达到它们的最大利用率。理论和实践都已证明，利用“L=S”准则，对于调节缺页率是十分有效的。 </p>
<p> 选择暂停的进程</p>
<p>当多道程序度偏高时，已影响到处理机的利用率，为了防止发生“抖动”，系统必须减少多道程序的数目。 </p>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p>
<h3 id="分段虚拟存储管理"><a href="#分段虚拟存储管理" class="headerlink" title="分段虚拟存储管理"></a>分段虚拟存储管理</h3><h3 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h3><p>－分段虚拟存储管理原理同分页虚拟存储管理原理一样，在程序运行前，不必调入所有分段，只需先调入若干个分段便可启动运行。当所访问的段不在内存中时，可请求操作系统将所缺的段调入内存</p>
<h4 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h4><p> －分段虚拟存储管理中的段表包括：段名、段长、段的基址、存取方式、访问位、修改位、存在位、增补位和外存地址</p>
<h4 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h4><p> 在请求分段系统中采用的是请求调段策略。每当发现运行进程所要访问的段尚未调入内存时，便由缺段中断机构产生一缺段中断信号，进入OS后，由缺段中断处理程序将所需的段调入内存。与缺页中断机构类似，缺段中断机构同样需要在一条指令的执行期间产生和处理中断，以及在一条指令执行期间，可能产生多次缺段中断。但由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中，和一组信息被分割在两个分段中的情况。 </p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，然后才能再利用段表进行地址变换。为此，在地址变换机构中又增加了某些功能，如缺段中断的请求及处理等。 </p>
<h3 id="段的共享"><a href="#段的共享" class="headerlink" title="段的共享"></a>段的共享</h3><p>利用段的动态链接很容易实现段的共享，一个共享段在不同作业中可具有不同的段号<br> －设立一张共享段表对段的共享进行集中管理</p>
<ul>
<li>可重入代码又称为“纯代码”，是一种允许多个进程同时访问的代码。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">shrilly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">https://youranner.github.io/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/01/%E5%9B%BE/"><img class="prev-cover" src="/2020/12/01/%E5%9B%BE/background.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">图</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/27/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"><img class="next-cover" src="/2020/11/27/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">模拟电子技术基础期末复习</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">shrilly</div><div class="author-info__description">blog and share my life</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">record my life</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统的目标和作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">操作系统的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">操作系统的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的发展过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统的基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统的结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">进程的描述与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">前驱图和程序执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">前驱图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">程序顺序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">程序并发执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.2.</span> <span class="toc-text">进程的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程的定义和特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-PCB"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">定义(PCB)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">特征</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">进程的基本状态及转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">进程的三种基本状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">三种基本状态的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">创建状态和终止状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">挂起操作和进程状态的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">进程管理中的数据结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">2.3.1.</span> <span class="toc-text">操作系统内核</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%AF%E6%92%91%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">支撑功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">资源管理功能</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">进程的层次结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">进程图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">引起创建进程的事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-Creation-of-Process"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">进程的创建(Creation of Process)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">进程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E8%B5%B7%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-Termination-of-Process-%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">引起进程终止(Termination of Process)的事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">进程的终止过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">2.3.4.</span> <span class="toc-text">进程的阻塞与唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="toc-number">2.3.5.</span> <span class="toc-text">进程的挂起与激活</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.4.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">进程同步的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">两种形式的制约关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90-Critical-Resouce"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">临界资源(Critical Resouce)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA-critical-section"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">临界区(critical section)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%BA%94%E9%81%B5%E5%BE%AA%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">同步机制应遵循的规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">硬件同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%B8%AD%E6%96%AD"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">关中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Test-and-Set%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">利用Test-and-Set指令实现互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Swap%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">利用Swap指令实现进程互斥</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.3.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">信号量的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">利用信号量实现进程互斥</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E8%B6%8B%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">利用信号量实现前趋关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">经典进程的同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.1.</span> <span class="toc-text">决生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.3.</span> <span class="toc-text">读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.6.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">进程通信的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.2.</span> <span class="toc-text">消息传递通信的实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.</span> <span class="toc-text">线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E4%BD%9C%E4%B8%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E5%88%86%E6%B4%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">线程——作为调度和分派的基本单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.7.2.</span> <span class="toc-text">线程与进程的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.7.3.</span> <span class="toc-text">线程的状态和线程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%89%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">线程运行的三个状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97TCB"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">线程控制块TCB</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BOS%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">多线程OS中的进程属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.</span> <span class="toc-text">线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.1.</span> <span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8BKST-Kernel-Supported-Threads"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">内核支持线程KST(Kernel Supported Threads)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8BULT-User-Level-Threads"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">用户级线程ULT(User Level Threads)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="toc-number">2.8.2.</span> <span class="toc-text">线程的创建和终止</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.8.2.1.</span> <span class="toc-text">线程的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.8.2.2.</span> <span class="toc-text">线程的终止</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">处理机调度的层次和调度算法的目标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">处理机调度的层次</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.1.</span> <span class="toc-text">处理机调度算法的目标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B1%E5%90%8C%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">处理机调度算法的共同目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">批处理系统的目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">分时系统的目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">实时系统的目标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">作业与作业调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E4%B8%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">批处理系统中的作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">作业调度的主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1-FCFS"><span class="toc-number">3.2.3.</span> <span class="toc-text">先来先服务(FCFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88-SJF-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">短作业优先(SJF)调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.6.</span> <span class="toc-text">高响应比优先调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B-%E7%A8%8B-%E8%B0%83-%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">进 程 调 度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">进程调度的任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程调度机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">进程调度方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">非抢占方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">抢占方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.4.</span> <span class="toc-text">轮转调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="toc-number">3.3.5.</span> <span class="toc-text">优先级调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">静态优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">动态优先级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.6.</span> <span class="toc-text">多队列调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-multileved-feedback-queue-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.7.</span> <span class="toc-text">多级反馈队列(multileved feedback queue)调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E-%E6%97%B6-%E8%B0%83-%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">实 时 调 度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">实现实时调度的基本条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.2.</span> <span class="toc-text">实时调度算法的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88EDF"><span class="toc-number">3.4.3.</span> <span class="toc-text">最早截止时间优先EDF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88LLF"><span class="toc-number">3.4.4.</span> <span class="toc-text">最低松弛度优先LLF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB-%E9%94%81-%E6%A6%82-%E8%BF%B0"><span class="toc-number">3.5.</span> <span class="toc-text">死 锁 概 述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.1.</span> <span class="toc-text">资源问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">3.5.2.</span> <span class="toc-text">计算机系统中的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.3.</span> <span class="toc-text">产生死锁的必要条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84-%E9%98%B2-%E6%AD%BB-%E9%94%81"><span class="toc-number">3.6.</span> <span class="toc-text">预 防 死 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF-%E5%85%8D-%E6%AD%BB-%E9%94%81"><span class="toc-number">3.7.</span> <span class="toc-text">避 免 死 锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">3.8.</span> <span class="toc-text">死锁的检测与解除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 存储器的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 程序的装入和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 程序的装入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">1.绝对装入方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">2.静态重定位装入方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">3.动态重定位装入方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 程序的链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">1.静态链接：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">2.装入时动态链接：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">3.运行时动态链接：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 连续分配存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2 固定分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8A%80%E6%9C%AF"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1、基本原理及技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%88%86%E5%8C%BA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">划分分区的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%8A%A8%E6%80%81-%E5%8F%AF%E5%8F%98-%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3 动态(可变)分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">1.分区分配中的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">2.分区分配算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">基于顺序搜索的分区分配算法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">基于索引搜索的分区分配算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.4.</span> <span class="toc-text">3.分区分配操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.回收内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.6.</span> <span class="toc-text">4.3.4可重定位分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">1. 动态重定位的引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">2. 动态重定位的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.6.3.</span> <span class="toc-text">3. 动态重定位分区分配算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%AF%B9%E6%8D%A2%EF%BC%88Swapping%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 对换（Swapping）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">4.4.1.</span> <span class="toc-text">分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%8D%A2%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.4.2.</span> <span class="toc-text">实现进程对换，系统必须具备的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">对换空间的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8D%A2%E5%87%BA%E4%B8%8E%E6%8D%A2%E5%85%A5"><span class="toc-number">4.4.4.</span> <span class="toc-text">进程的换出与换入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.5.</span> <span class="toc-text">什么是覆盖技术?什么是对换技术?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 分页存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1 分页存储管理的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%89%A9%E7%90%86%E5%9D%97"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">1.页面和物理块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">2. 地址结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2 地址变换机构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">1. 基本的地址变换机构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">2.具有快表的地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3 有效访问内存的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.5.4.</span> <span class="toc-text">4.5.4 两级和多级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1分段存储管理方式的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2 分段系统的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E6%AE%B5"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">1.分段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AE%B5%E8%A1%A8"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">2.段表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">3. 地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-4%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.4段页式存储管理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">局部性原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">时间局部性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">空间局部性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">5.1.2.</span> <span class="toc-text">虚拟存储器的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">虚拟存储器定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">5.2分页虚拟存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">分页虚拟存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.3.</span> <span class="toc-text">缺页中断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%8E%E4%B8%80%E8%88%AC%E7%9A%84%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">缺页中断与与一般的中断的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">5.2.4.</span> <span class="toc-text">地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.2.5.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E9%A1%B5%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.6.</span> <span class="toc-text">调页策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%B0%83%E9%A1%B5%EF%BC%9F"><span class="toc-number">5.2.6.1.</span> <span class="toc-text">何时调页？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E5%A4%84%E8%B0%83%E9%A1%B5%EF%BC%9F"><span class="toc-number">5.2.6.2.</span> <span class="toc-text">何处调页？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E8%B0%83%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.6.3.</span> <span class="toc-text">页面调入过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E7%8E%87"><span class="toc-number">5.2.6.4.</span> <span class="toc-text">缺页率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">最佳置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.0.2.</span> <span class="toc-text">先进先出算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%EF%BC%88LRU%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.0.3.</span> <span class="toc-text">最近最久未使用（LRU）算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8-Least-Frequently-Used%EF%BC%8CLFU-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.0.4.</span> <span class="toc-text">最少使用(Least Frequently Used，LFU)置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8BClock%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.0.5.</span> <span class="toc-text">改进型Clock置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95-Page-Buffering-Algorithm%EF%BC%8CPBA"><span class="toc-number">5.3.0.6.</span> <span class="toc-text">页面缓冲算法(Page Buffering Algorithm，PBA)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">5.4.</span> <span class="toc-text">抖动和工作集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-number">5.4.1.</span> <span class="toc-text">抖动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%8A%96%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">预防抖动的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">工作集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text">分段虚拟存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.6.</span> <span class="toc-text">基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%AE%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.1.</span> <span class="toc-text">请求段表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E6%AE%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">5.6.2.</span> <span class="toc-text">缺段中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">5.6.3.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-number">5.7.</span> <span class="toc-text">段的共享</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/07/%E8%B4%AA%E5%90%83%E8%9B%87/" title="贪吃蛇"><img src="/2020/12/07/%E8%B4%AA%E5%90%83%E8%9B%87/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="贪吃蛇"/></a><div class="content"><a class="title" href="/2020/12/07/%E8%B4%AA%E5%90%83%E8%9B%87/" title="贪吃蛇">贪吃蛇</a><time datetime="2020-12-07T12:43:26.000Z" title="Created 2020-12-07 20:43:26">2020-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/%E6%A0%88/" title="栈"><img src="/2020/12/03/%E6%A0%88/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈"/></a><div class="content"><a class="title" href="/2020/12/03/%E6%A0%88/" title="栈">栈</a><time datetime="2020-12-03T07:45:01.000Z" title="Created 2020-12-03 15:45:01">2020-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/01/%E5%9B%BE/" title="图"><img src="/2020/12/01/%E5%9B%BE/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图"/></a><div class="content"><a class="title" href="/2020/12/01/%E5%9B%BE/" title="图">图</a><time datetime="2020-12-01T05:03:00.000Z" title="Created 2020-12-01 13:03:00">2020-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="操作系统期末复习"><img src="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统期末复习"/></a><div class="content"><a class="title" href="/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="操作系统期末复习">操作系统期末复习</a><time datetime="2020-11-29T03:40:25.000Z" title="Created 2020-11-29 11:40:25">2020-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/27/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="模拟电子技术基础期末复习"><img src="/2020/11/27/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="模拟电子技术基础期末复习"/></a><div class="content"><a class="title" href="/2020/11/27/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="模拟电子技术基础期末复习">模拟电子技术基础期末复习</a><time datetime="2020-11-27T05:31:38.000Z" title="Created 2020-11-27 13:31:38">2020-11-27</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/2020/11/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/background.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 By shrilly</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>